{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"colors-core Core color functionality. Installing Python 3.7 or above is required. pip Installing the library with pip is quite simple: $ pip install colors-core Alternatively, the library can be installed from source: $ git clone https://github.com/nekitdev/colors-core.git $ cd colors-core $ python -m pip install . poetry You can add colors-core as a dependency with the following command: $ poetry add colors-core Or by directly specifying it in the configuration like so: [tool.poetry.dependencies] colors-core = \"^1.0.0\" Alternatively, you can add it directly from the source: [tool.poetry.dependencies.colors-core] git = \"https://github.com/nekitdev/colors-core.git\" Examples >>> from colors import Color >>> color = Color ( 0x000000 ) >>> print ( color ) #000000 >>> color . to_rgb () ( 0 , 0 , 0 ) >>> color . to_rgba ( 0 ) ( 0 , 0 , 0 , 0 ) >>> color . to_hsv () ( 0.0 , 0.0 , 0.0 ) Documentation You can find the documentation here . Support If you need support with the library, you can send an email or refer to the official Discord server . Changelog You can find the changelog here . Security Policy You can find the Security Policy of colors-core here . Contributing If you are interested in contributing to colors-core , make sure to take a look at the Contributing Guide , as well as the Code of Conduct . License colors-core is licensed under the MIT License terms. See License for details.","title":"Index"},{"location":"#colors-core","text":"Core color functionality.","title":"colors-core"},{"location":"#installing","text":"Python 3.7 or above is required.","title":"Installing"},{"location":"#pip","text":"Installing the library with pip is quite simple: $ pip install colors-core Alternatively, the library can be installed from source: $ git clone https://github.com/nekitdev/colors-core.git $ cd colors-core $ python -m pip install .","title":"pip"},{"location":"#poetry","text":"You can add colors-core as a dependency with the following command: $ poetry add colors-core Or by directly specifying it in the configuration like so: [tool.poetry.dependencies] colors-core = \"^1.0.0\" Alternatively, you can add it directly from the source: [tool.poetry.dependencies.colors-core] git = \"https://github.com/nekitdev/colors-core.git\"","title":"poetry"},{"location":"#examples","text":">>> from colors import Color >>> color = Color ( 0x000000 ) >>> print ( color ) #000000 >>> color . to_rgb () ( 0 , 0 , 0 ) >>> color . to_rgba ( 0 ) ( 0 , 0 , 0 , 0 ) >>> color . to_hsv () ( 0.0 , 0.0 , 0.0 )","title":"Examples"},{"location":"#documentation","text":"You can find the documentation here .","title":"Documentation"},{"location":"#support","text":"If you need support with the library, you can send an email or refer to the official Discord server .","title":"Support"},{"location":"#changelog","text":"You can find the changelog here .","title":"Changelog"},{"location":"#security-policy","text":"You can find the Security Policy of colors-core here .","title":"Security Policy"},{"location":"#contributing","text":"If you are interested in contributing to colors-core , make sure to take a look at the Contributing Guide , as well as the Code of Conduct .","title":"Contributing"},{"location":"#license","text":"colors-core is licensed under the MIT License terms. See License for details.","title":"License"},{"location":"changelog/","text":"Changelog 1.0.0 (2023-04-12) Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#100-2023-04-12","text":"Initial release.","title":"1.0.0 (2023-04-12)"},{"location":"code_of_conduct/","text":"Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev . All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct . Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq . Translations are available at https://contributor-covenant.org/translations .","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev . All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"code_of_conduct/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"code_of_conduct/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"code_of_conduct/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"code_of_conduct/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"code_of_conduct/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct . Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq . Translations are available at https://contributor-covenant.org/translations .","title":"Attribution"},{"location":"contributing/","text":"Contributing Guide","title":"Contributing"},{"location":"contributing/#contributing-guide","text":"","title":"Contributing Guide"},{"location":"reference/","text":"Reference Color Source code in colors/core.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 @frozen ( order = True ) class Color : value : int = field ( default = BLACK , repr = hex_value ) \"\"\"The color value in range from [`BLACK`][colors.constants.BLACK] to [`WHITE`][colors.constants.WHITE] (both inclusive). \"\"\" @value . validator def validate_value ( self , attribute : Attribute [ int ], value : int ) -> None : validate_value ( value ) @classmethod def black ( cls : Type [ C ]) -> C : \"\"\"Creates a color with the [`BLACK`][colors.constants.BLACK] value. Returns: The color with the black value. \"\"\" return cls ( BLACK ) @classmethod def white ( cls : Type [ C ]) -> C : \"\"\"Creates a color with the [`WHITE`][colors.constants.WHITE] value. Returns: The color with the white value. \"\"\" return cls ( WHITE ) def is_black ( self ) -> bool : \"\"\"Checks if the color has the [`BLACK`][colors.constants.BLACK] value. Returns: Whether the color has the black value. \"\"\" return self . value == BLACK def is_white ( self ) -> bool : \"\"\"Checks if the color has the [`WHITE`][colors.constants.WHITE] value. Returns: Whether the color has the white value. \"\"\" return self . value == WHITE def get_byte ( self , byte : int ) -> int : \"\"\"Fetches the byte from the color value. Arguments: byte: The byte index. Returns: The byte value. \"\"\" return ( self . value >> ( BITS * byte )) & BYTE @property def red ( self ) -> int : \"\"\"The red channel value.\"\"\" return self . get_byte ( RED_BYTE ) @property def green ( self ) -> int : \"\"\"The green channel value.\"\"\" return self . get_byte ( GREEN_BYTE ) @property def blue ( self ) -> int : \"\"\"The blue channel value.\"\"\" return self . get_byte ( BLUE_BYTE ) r = red \"\"\"An alias of [`red`][colors.core.Color.red].\"\"\" g = green \"\"\"An alias of [`green`][colors.core.Color.green].\"\"\" b = blue \"\"\"An alias of [`blue`][colors.core.Color.blue].\"\"\" def ansi_escape ( self , string : Optional [ str ] = None ) -> str : \"\"\"Paints the `string` with the color using ANSI escape sequences. If the `string` is not given, [`color.to_hex()`][colors.core.Color.to_hex] will be used. Arguments: string: The string to paint. Returns: The painted string. \"\"\" if string is None : string = self . to_hex () red , green , blue = self . to_rgb () return ANSI_COLOR . format ( red , green , blue ) + string + ANSI_RESET paint = ansi_escape \"\"\"An alias of [`ansi_escape`][colors.core.Color.ansi_escape].\"\"\" @classmethod def from_hex ( cls : Type [ C ], string : str ) -> C : \"\"\"Creates a color from the hex `string` (e.g. `#000000`, `0x000000`, or simply `000000`). This method uses the [`int`][int] function with the hex base to parse the string, replacing `#` with `0x`. Arguments: string: The hex string. Returns: The color with the parsed hex value. \"\"\" return cls ( int ( string . replace ( HEX_STRING_PREFIX , HEX_VALUE_PREFIX ), HEX_BASE )) def to_hex ( self ) -> str : \"\"\"Converts the color to the hex string (e.g. `#FFFFFF`). Returns: The color hex string. \"\"\" return hex_string ( self . value ) def to_hex_value ( self ) -> str : \"\"\"Converts the color to the hex *value* string (e.g. `0xFFFFFF`). Returns: The color hex *value* string. \"\"\" return hex_value ( self . value ) @classmethod def from_rgb ( cls : Type [ C ], red : int , green : int , blue : int ) -> C : \"\"\"Creates a color from *RGB* values (each in `[0, 255]` range). Arguments: red: The red channel value. green: The green channel value. blue: The blue channel value. Returns: The color created from *RGB* values. \"\"\" return cls ( value_from_rgb ( red , green , blue )) def to_rgb ( self ) -> RGB : \"\"\"Converts the color to *RGB* values (each in `[0, 255]` range). Returns: The *RGB* values. \"\"\" return ( self . red , self . blue , self . green ) @classmethod def from_rgba ( cls : Type [ C ], red : int , green : int , blue : int , alpha : int ) -> C : \"\"\"Creates a color from *RGBA* values (each in `[0, 255]` range). Note: The *alpha* channel is simply ignored. Arguments: red: The red channel value. green: The green channel value. blue: The blue channel value. alpha: The alpha channel value. Returns: The color created from *RGBA* channel values. \"\"\" return cls . from_rgb ( red , green , blue ) def to_rgba ( self , alpha : int = BYTE ) -> RGBA : \"\"\"Converts the color to *RGBA* channel values (each in `[0, 255]` range). Arguments: alpha: The alpha channel value. Returns: The *RGBA* values. \"\"\" return ( self . red , self . green , self . blue , alpha ) @classmethod def from_hsv ( cls : Type [ C ], hue : float , saturation : float , value : float ) -> C : \"\"\"Creates a color from *HSV* values (each in `[0, 1]` range). Arguments: hue: The hue of the color. saturation: The saturation of the color. value: The value of the color. Returns: The color created from *HSV* values. \"\"\" red , green , blue = map ( float_to_byte , hsv_to_rgb ( hue , saturation , value )) return cls . from_rgb ( red , green , blue ) def to_hsv ( self ) -> HSV : \"\"\"Converts the color to *HSV* values (each in `[0, 1]` range). Returns: The *HSV* values. \"\"\" red , green , blue = map ( byte_to_float , self . to_rgb ()) return rgb_to_hsv ( red , green , blue ) value : int = field ( default = BLACK , repr = hex_value ) class-attribute The color value in range from BLACK to WHITE (both inclusive). red : int property The red channel value. green : int property The green channel value. blue : int property The blue channel value. r = red class-attribute An alias of red . g = green class-attribute An alias of green . b = blue class-attribute An alias of blue . paint = ansi_escape class-attribute An alias of ansi_escape . black () -> C classmethod Creates a color with the BLACK value. Returns: Type Description C The color with the black value. Source code in colors/core.py 81 82 83 84 85 86 87 88 @classmethod def black ( cls : Type [ C ]) -> C : \"\"\"Creates a color with the [`BLACK`][colors.constants.BLACK] value. Returns: The color with the black value. \"\"\" return cls ( BLACK ) white () -> C classmethod Creates a color with the WHITE value. Returns: Type Description C The color with the white value. Source code in colors/core.py 90 91 92 93 94 95 96 97 @classmethod def white ( cls : Type [ C ]) -> C : \"\"\"Creates a color with the [`WHITE`][colors.constants.WHITE] value. Returns: The color with the white value. \"\"\" return cls ( WHITE ) is_black () -> bool Checks if the color has the BLACK value. Returns: Type Description bool Whether the color has the black value. Source code in colors/core.py 99 100 101 102 103 104 105 def is_black ( self ) -> bool : \"\"\"Checks if the color has the [`BLACK`][colors.constants.BLACK] value. Returns: Whether the color has the black value. \"\"\" return self . value == BLACK is_white () -> bool Checks if the color has the WHITE value. Returns: Type Description bool Whether the color has the white value. Source code in colors/core.py 107 108 109 110 111 112 113 def is_white ( self ) -> bool : \"\"\"Checks if the color has the [`WHITE`][colors.constants.WHITE] value. Returns: Whether the color has the white value. \"\"\" return self . value == WHITE get_byte ( byte : int ) -> int Fetches the byte from the color value. Parameters: Name Type Description Default byte int The byte index. required Returns: Type Description int The byte value. Source code in colors/core.py 115 116 117 118 119 120 121 122 123 124 def get_byte ( self , byte : int ) -> int : \"\"\"Fetches the byte from the color value. Arguments: byte: The byte index. Returns: The byte value. \"\"\" return ( self . value >> ( BITS * byte )) & BYTE ansi_escape ( string : Optional [ str ] = None ) -> str Paints the string with the color using ANSI escape sequences. If the string is not given, color.to_hex() will be used. Parameters: Name Type Description Default string Optional [ str ] The string to paint. None Returns: Type Description str The painted string. Source code in colors/core.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def ansi_escape ( self , string : Optional [ str ] = None ) -> str : \"\"\"Paints the `string` with the color using ANSI escape sequences. If the `string` is not given, [`color.to_hex()`][colors.core.Color.to_hex] will be used. Arguments: string: The string to paint. Returns: The painted string. \"\"\" if string is None : string = self . to_hex () red , green , blue = self . to_rgb () return ANSI_COLOR . format ( red , green , blue ) + string + ANSI_RESET from_hex ( string : str ) -> C classmethod Creates a color from the hex string (e.g. #000000 , 0x000000 , or simply 000000 ). This method uses the int function with the hex base to parse the string, replacing # with 0x . Parameters: Name Type Description Default string str The hex string. required Returns: Type Description C The color with the parsed hex value. Source code in colors/core.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @classmethod def from_hex ( cls : Type [ C ], string : str ) -> C : \"\"\"Creates a color from the hex `string` (e.g. `#000000`, `0x000000`, or simply `000000`). This method uses the [`int`][int] function with the hex base to parse the string, replacing `#` with `0x`. Arguments: string: The hex string. Returns: The color with the parsed hex value. \"\"\" return cls ( int ( string . replace ( HEX_STRING_PREFIX , HEX_VALUE_PREFIX ), HEX_BASE )) to_hex () -> str Converts the color to the hex string (e.g. #FFFFFF ). Returns: Type Description str The color hex string. Source code in colors/core.py 184 185 186 187 188 189 190 def to_hex ( self ) -> str : \"\"\"Converts the color to the hex string (e.g. `#FFFFFF`). Returns: The color hex string. \"\"\" return hex_string ( self . value ) to_hex_value () -> str Converts the color to the hex value string (e.g. 0xFFFFFF ). Returns: Type Description str The color hex value string. Source code in colors/core.py 192 193 194 195 196 197 198 def to_hex_value ( self ) -> str : \"\"\"Converts the color to the hex *value* string (e.g. `0xFFFFFF`). Returns: The color hex *value* string. \"\"\" return hex_value ( self . value ) from_rgb ( red : int , green : int , blue : int ) -> C classmethod Creates a color from RGB values (each in [0, 255] range). Parameters: Name Type Description Default red int The red channel value. required green int The green channel value. required blue int The blue channel value. required Returns: Type Description C The color created from RGB values. Source code in colors/core.py 200 201 202 203 204 205 206 207 208 209 210 211 212 @classmethod def from_rgb ( cls : Type [ C ], red : int , green : int , blue : int ) -> C : \"\"\"Creates a color from *RGB* values (each in `[0, 255]` range). Arguments: red: The red channel value. green: The green channel value. blue: The blue channel value. Returns: The color created from *RGB* values. \"\"\" return cls ( value_from_rgb ( red , green , blue )) to_rgb () -> RGB Converts the color to RGB values (each in [0, 255] range). Returns: Type Description RGB The RGB values. Source code in colors/core.py 214 215 216 217 218 219 220 def to_rgb ( self ) -> RGB : \"\"\"Converts the color to *RGB* values (each in `[0, 255]` range). Returns: The *RGB* values. \"\"\" return ( self . red , self . blue , self . green ) from_rgba ( red : int , green : int , blue : int , alpha : int ) -> C classmethod Creates a color from RGBA values (each in [0, 255] range). Note The alpha channel is simply ignored. Parameters: Name Type Description Default red int The red channel value. required green int The green channel value. required blue int The blue channel value. required alpha int The alpha channel value. required Returns: Type Description C The color created from RGBA channel values. Source code in colors/core.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 @classmethod def from_rgba ( cls : Type [ C ], red : int , green : int , blue : int , alpha : int ) -> C : \"\"\"Creates a color from *RGBA* values (each in `[0, 255]` range). Note: The *alpha* channel is simply ignored. Arguments: red: The red channel value. green: The green channel value. blue: The blue channel value. alpha: The alpha channel value. Returns: The color created from *RGBA* channel values. \"\"\" return cls . from_rgb ( red , green , blue ) to_rgba ( alpha : int = BYTE ) -> RGBA Converts the color to RGBA channel values (each in [0, 255] range). Parameters: Name Type Description Default alpha int The alpha channel value. BYTE Returns: Type Description RGBA The RGBA values. Source code in colors/core.py 240 241 242 243 244 245 246 247 248 249 def to_rgba ( self , alpha : int = BYTE ) -> RGBA : \"\"\"Converts the color to *RGBA* channel values (each in `[0, 255]` range). Arguments: alpha: The alpha channel value. Returns: The *RGBA* values. \"\"\" return ( self . red , self . green , self . blue , alpha ) from_hsv ( hue : float , saturation : float , value : float ) -> C classmethod Creates a color from HSV values (each in [0, 1] range). Parameters: Name Type Description Default hue float The hue of the color. required saturation float The saturation of the color. required value float The value of the color. required Returns: Type Description C The color created from HSV values. Source code in colors/core.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 @classmethod def from_hsv ( cls : Type [ C ], hue : float , saturation : float , value : float ) -> C : \"\"\"Creates a color from *HSV* values (each in `[0, 1]` range). Arguments: hue: The hue of the color. saturation: The saturation of the color. value: The value of the color. Returns: The color created from *HSV* values. \"\"\" red , green , blue = map ( float_to_byte , hsv_to_rgb ( hue , saturation , value )) return cls . from_rgb ( red , green , blue ) to_hsv () -> HSV Converts the color to HSV values (each in [0, 1] range). Returns: Type Description HSV The HSV values. Source code in colors/core.py 267 268 269 270 271 272 273 274 275 def to_hsv ( self ) -> HSV : \"\"\"Converts the color to *HSV* values (each in `[0, 1]` range). Returns: The *HSV* values. \"\"\" red , green , blue = map ( byte_to_float , self . to_rgb ()) return rgb_to_hsv ( red , green , blue ) ZERO = 0 module-attribute The zero byte value. BYTE = 255 module-attribute The full byte value. BITS = BYTE . bit_length () module-attribute The amount of bits in one byte. DOUBLE_BITS = BITS + BITS module-attribute The amount of bits in two bytes. BLACK = 0 module-attribute The black color value. WHITE = 16777215 module-attribute The white color value. RED_BYTE = 2 module-attribute The byte representing the red channel. GREEN_BYTE = 1 module-attribute The byte representing the green channel. BLUE_BYTE = 0 module-attribute The byte representing the blue channel. RGB = Tuple [ int , int , int ] module-attribute Represents RGB color tuples. RGBA = Tuple [ int , int , int , int ] module-attribute Represents RGBA color tuples. HSV = Tuple [ float , float , float ] module-attribute Represents HSV color tuples.","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#colors.core.Color","text":"Source code in colors/core.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 @frozen ( order = True ) class Color : value : int = field ( default = BLACK , repr = hex_value ) \"\"\"The color value in range from [`BLACK`][colors.constants.BLACK] to [`WHITE`][colors.constants.WHITE] (both inclusive). \"\"\" @value . validator def validate_value ( self , attribute : Attribute [ int ], value : int ) -> None : validate_value ( value ) @classmethod def black ( cls : Type [ C ]) -> C : \"\"\"Creates a color with the [`BLACK`][colors.constants.BLACK] value. Returns: The color with the black value. \"\"\" return cls ( BLACK ) @classmethod def white ( cls : Type [ C ]) -> C : \"\"\"Creates a color with the [`WHITE`][colors.constants.WHITE] value. Returns: The color with the white value. \"\"\" return cls ( WHITE ) def is_black ( self ) -> bool : \"\"\"Checks if the color has the [`BLACK`][colors.constants.BLACK] value. Returns: Whether the color has the black value. \"\"\" return self . value == BLACK def is_white ( self ) -> bool : \"\"\"Checks if the color has the [`WHITE`][colors.constants.WHITE] value. Returns: Whether the color has the white value. \"\"\" return self . value == WHITE def get_byte ( self , byte : int ) -> int : \"\"\"Fetches the byte from the color value. Arguments: byte: The byte index. Returns: The byte value. \"\"\" return ( self . value >> ( BITS * byte )) & BYTE @property def red ( self ) -> int : \"\"\"The red channel value.\"\"\" return self . get_byte ( RED_BYTE ) @property def green ( self ) -> int : \"\"\"The green channel value.\"\"\" return self . get_byte ( GREEN_BYTE ) @property def blue ( self ) -> int : \"\"\"The blue channel value.\"\"\" return self . get_byte ( BLUE_BYTE ) r = red \"\"\"An alias of [`red`][colors.core.Color.red].\"\"\" g = green \"\"\"An alias of [`green`][colors.core.Color.green].\"\"\" b = blue \"\"\"An alias of [`blue`][colors.core.Color.blue].\"\"\" def ansi_escape ( self , string : Optional [ str ] = None ) -> str : \"\"\"Paints the `string` with the color using ANSI escape sequences. If the `string` is not given, [`color.to_hex()`][colors.core.Color.to_hex] will be used. Arguments: string: The string to paint. Returns: The painted string. \"\"\" if string is None : string = self . to_hex () red , green , blue = self . to_rgb () return ANSI_COLOR . format ( red , green , blue ) + string + ANSI_RESET paint = ansi_escape \"\"\"An alias of [`ansi_escape`][colors.core.Color.ansi_escape].\"\"\" @classmethod def from_hex ( cls : Type [ C ], string : str ) -> C : \"\"\"Creates a color from the hex `string` (e.g. `#000000`, `0x000000`, or simply `000000`). This method uses the [`int`][int] function with the hex base to parse the string, replacing `#` with `0x`. Arguments: string: The hex string. Returns: The color with the parsed hex value. \"\"\" return cls ( int ( string . replace ( HEX_STRING_PREFIX , HEX_VALUE_PREFIX ), HEX_BASE )) def to_hex ( self ) -> str : \"\"\"Converts the color to the hex string (e.g. `#FFFFFF`). Returns: The color hex string. \"\"\" return hex_string ( self . value ) def to_hex_value ( self ) -> str : \"\"\"Converts the color to the hex *value* string (e.g. `0xFFFFFF`). Returns: The color hex *value* string. \"\"\" return hex_value ( self . value ) @classmethod def from_rgb ( cls : Type [ C ], red : int , green : int , blue : int ) -> C : \"\"\"Creates a color from *RGB* values (each in `[0, 255]` range). Arguments: red: The red channel value. green: The green channel value. blue: The blue channel value. Returns: The color created from *RGB* values. \"\"\" return cls ( value_from_rgb ( red , green , blue )) def to_rgb ( self ) -> RGB : \"\"\"Converts the color to *RGB* values (each in `[0, 255]` range). Returns: The *RGB* values. \"\"\" return ( self . red , self . blue , self . green ) @classmethod def from_rgba ( cls : Type [ C ], red : int , green : int , blue : int , alpha : int ) -> C : \"\"\"Creates a color from *RGBA* values (each in `[0, 255]` range). Note: The *alpha* channel is simply ignored. Arguments: red: The red channel value. green: The green channel value. blue: The blue channel value. alpha: The alpha channel value. Returns: The color created from *RGBA* channel values. \"\"\" return cls . from_rgb ( red , green , blue ) def to_rgba ( self , alpha : int = BYTE ) -> RGBA : \"\"\"Converts the color to *RGBA* channel values (each in `[0, 255]` range). Arguments: alpha: The alpha channel value. Returns: The *RGBA* values. \"\"\" return ( self . red , self . green , self . blue , alpha ) @classmethod def from_hsv ( cls : Type [ C ], hue : float , saturation : float , value : float ) -> C : \"\"\"Creates a color from *HSV* values (each in `[0, 1]` range). Arguments: hue: The hue of the color. saturation: The saturation of the color. value: The value of the color. Returns: The color created from *HSV* values. \"\"\" red , green , blue = map ( float_to_byte , hsv_to_rgb ( hue , saturation , value )) return cls . from_rgb ( red , green , blue ) def to_hsv ( self ) -> HSV : \"\"\"Converts the color to *HSV* values (each in `[0, 1]` range). Returns: The *HSV* values. \"\"\" red , green , blue = map ( byte_to_float , self . to_rgb ()) return rgb_to_hsv ( red , green , blue )","title":"Color"},{"location":"reference/#colors.core.Color.value","text":"The color value in range from BLACK to WHITE (both inclusive).","title":"value"},{"location":"reference/#colors.core.Color.red","text":"The red channel value.","title":"red"},{"location":"reference/#colors.core.Color.green","text":"The green channel value.","title":"green"},{"location":"reference/#colors.core.Color.blue","text":"The blue channel value.","title":"blue"},{"location":"reference/#colors.core.Color.r","text":"An alias of red .","title":"r"},{"location":"reference/#colors.core.Color.g","text":"An alias of green .","title":"g"},{"location":"reference/#colors.core.Color.b","text":"An alias of blue .","title":"b"},{"location":"reference/#colors.core.Color.paint","text":"An alias of ansi_escape .","title":"paint"},{"location":"reference/#colors.core.Color.black","text":"Creates a color with the BLACK value. Returns: Type Description C The color with the black value. Source code in colors/core.py 81 82 83 84 85 86 87 88 @classmethod def black ( cls : Type [ C ]) -> C : \"\"\"Creates a color with the [`BLACK`][colors.constants.BLACK] value. Returns: The color with the black value. \"\"\" return cls ( BLACK )","title":"black()"},{"location":"reference/#colors.core.Color.white","text":"Creates a color with the WHITE value. Returns: Type Description C The color with the white value. Source code in colors/core.py 90 91 92 93 94 95 96 97 @classmethod def white ( cls : Type [ C ]) -> C : \"\"\"Creates a color with the [`WHITE`][colors.constants.WHITE] value. Returns: The color with the white value. \"\"\" return cls ( WHITE )","title":"white()"},{"location":"reference/#colors.core.Color.is_black","text":"Checks if the color has the BLACK value. Returns: Type Description bool Whether the color has the black value. Source code in colors/core.py 99 100 101 102 103 104 105 def is_black ( self ) -> bool : \"\"\"Checks if the color has the [`BLACK`][colors.constants.BLACK] value. Returns: Whether the color has the black value. \"\"\" return self . value == BLACK","title":"is_black()"},{"location":"reference/#colors.core.Color.is_white","text":"Checks if the color has the WHITE value. Returns: Type Description bool Whether the color has the white value. Source code in colors/core.py 107 108 109 110 111 112 113 def is_white ( self ) -> bool : \"\"\"Checks if the color has the [`WHITE`][colors.constants.WHITE] value. Returns: Whether the color has the white value. \"\"\" return self . value == WHITE","title":"is_white()"},{"location":"reference/#colors.core.Color.get_byte","text":"Fetches the byte from the color value. Parameters: Name Type Description Default byte int The byte index. required Returns: Type Description int The byte value. Source code in colors/core.py 115 116 117 118 119 120 121 122 123 124 def get_byte ( self , byte : int ) -> int : \"\"\"Fetches the byte from the color value. Arguments: byte: The byte index. Returns: The byte value. \"\"\" return ( self . value >> ( BITS * byte )) & BYTE","title":"get_byte()"},{"location":"reference/#colors.core.Color.ansi_escape","text":"Paints the string with the color using ANSI escape sequences. If the string is not given, color.to_hex() will be used. Parameters: Name Type Description Default string Optional [ str ] The string to paint. None Returns: Type Description str The painted string. Source code in colors/core.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def ansi_escape ( self , string : Optional [ str ] = None ) -> str : \"\"\"Paints the `string` with the color using ANSI escape sequences. If the `string` is not given, [`color.to_hex()`][colors.core.Color.to_hex] will be used. Arguments: string: The string to paint. Returns: The painted string. \"\"\" if string is None : string = self . to_hex () red , green , blue = self . to_rgb () return ANSI_COLOR . format ( red , green , blue ) + string + ANSI_RESET","title":"ansi_escape()"},{"location":"reference/#colors.core.Color.from_hex","text":"Creates a color from the hex string (e.g. #000000 , 0x000000 , or simply 000000 ). This method uses the int function with the hex base to parse the string, replacing # with 0x . Parameters: Name Type Description Default string str The hex string. required Returns: Type Description C The color with the parsed hex value. Source code in colors/core.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @classmethod def from_hex ( cls : Type [ C ], string : str ) -> C : \"\"\"Creates a color from the hex `string` (e.g. `#000000`, `0x000000`, or simply `000000`). This method uses the [`int`][int] function with the hex base to parse the string, replacing `#` with `0x`. Arguments: string: The hex string. Returns: The color with the parsed hex value. \"\"\" return cls ( int ( string . replace ( HEX_STRING_PREFIX , HEX_VALUE_PREFIX ), HEX_BASE ))","title":"from_hex()"},{"location":"reference/#colors.core.Color.to_hex","text":"Converts the color to the hex string (e.g. #FFFFFF ). Returns: Type Description str The color hex string. Source code in colors/core.py 184 185 186 187 188 189 190 def to_hex ( self ) -> str : \"\"\"Converts the color to the hex string (e.g. `#FFFFFF`). Returns: The color hex string. \"\"\" return hex_string ( self . value )","title":"to_hex()"},{"location":"reference/#colors.core.Color.to_hex_value","text":"Converts the color to the hex value string (e.g. 0xFFFFFF ). Returns: Type Description str The color hex value string. Source code in colors/core.py 192 193 194 195 196 197 198 def to_hex_value ( self ) -> str : \"\"\"Converts the color to the hex *value* string (e.g. `0xFFFFFF`). Returns: The color hex *value* string. \"\"\" return hex_value ( self . value )","title":"to_hex_value()"},{"location":"reference/#colors.core.Color.from_rgb","text":"Creates a color from RGB values (each in [0, 255] range). Parameters: Name Type Description Default red int The red channel value. required green int The green channel value. required blue int The blue channel value. required Returns: Type Description C The color created from RGB values. Source code in colors/core.py 200 201 202 203 204 205 206 207 208 209 210 211 212 @classmethod def from_rgb ( cls : Type [ C ], red : int , green : int , blue : int ) -> C : \"\"\"Creates a color from *RGB* values (each in `[0, 255]` range). Arguments: red: The red channel value. green: The green channel value. blue: The blue channel value. Returns: The color created from *RGB* values. \"\"\" return cls ( value_from_rgb ( red , green , blue ))","title":"from_rgb()"},{"location":"reference/#colors.core.Color.to_rgb","text":"Converts the color to RGB values (each in [0, 255] range). Returns: Type Description RGB The RGB values. Source code in colors/core.py 214 215 216 217 218 219 220 def to_rgb ( self ) -> RGB : \"\"\"Converts the color to *RGB* values (each in `[0, 255]` range). Returns: The *RGB* values. \"\"\" return ( self . red , self . blue , self . green )","title":"to_rgb()"},{"location":"reference/#colors.core.Color.from_rgba","text":"Creates a color from RGBA values (each in [0, 255] range). Note The alpha channel is simply ignored. Parameters: Name Type Description Default red int The red channel value. required green int The green channel value. required blue int The blue channel value. required alpha int The alpha channel value. required Returns: Type Description C The color created from RGBA channel values. Source code in colors/core.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 @classmethod def from_rgba ( cls : Type [ C ], red : int , green : int , blue : int , alpha : int ) -> C : \"\"\"Creates a color from *RGBA* values (each in `[0, 255]` range). Note: The *alpha* channel is simply ignored. Arguments: red: The red channel value. green: The green channel value. blue: The blue channel value. alpha: The alpha channel value. Returns: The color created from *RGBA* channel values. \"\"\" return cls . from_rgb ( red , green , blue )","title":"from_rgba()"},{"location":"reference/#colors.core.Color.to_rgba","text":"Converts the color to RGBA channel values (each in [0, 255] range). Parameters: Name Type Description Default alpha int The alpha channel value. BYTE Returns: Type Description RGBA The RGBA values. Source code in colors/core.py 240 241 242 243 244 245 246 247 248 249 def to_rgba ( self , alpha : int = BYTE ) -> RGBA : \"\"\"Converts the color to *RGBA* channel values (each in `[0, 255]` range). Arguments: alpha: The alpha channel value. Returns: The *RGBA* values. \"\"\" return ( self . red , self . green , self . blue , alpha )","title":"to_rgba()"},{"location":"reference/#colors.core.Color.from_hsv","text":"Creates a color from HSV values (each in [0, 1] range). Parameters: Name Type Description Default hue float The hue of the color. required saturation float The saturation of the color. required value float The value of the color. required Returns: Type Description C The color created from HSV values. Source code in colors/core.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 @classmethod def from_hsv ( cls : Type [ C ], hue : float , saturation : float , value : float ) -> C : \"\"\"Creates a color from *HSV* values (each in `[0, 1]` range). Arguments: hue: The hue of the color. saturation: The saturation of the color. value: The value of the color. Returns: The color created from *HSV* values. \"\"\" red , green , blue = map ( float_to_byte , hsv_to_rgb ( hue , saturation , value )) return cls . from_rgb ( red , green , blue )","title":"from_hsv()"},{"location":"reference/#colors.core.Color.to_hsv","text":"Converts the color to HSV values (each in [0, 1] range). Returns: Type Description HSV The HSV values. Source code in colors/core.py 267 268 269 270 271 272 273 274 275 def to_hsv ( self ) -> HSV : \"\"\"Converts the color to *HSV* values (each in `[0, 1]` range). Returns: The *HSV* values. \"\"\" red , green , blue = map ( byte_to_float , self . to_rgb ()) return rgb_to_hsv ( red , green , blue )","title":"to_hsv()"},{"location":"reference/#colors.constants.ZERO","text":"The zero byte value.","title":"ZERO"},{"location":"reference/#colors.constants.BYTE","text":"The full byte value.","title":"BYTE"},{"location":"reference/#colors.constants.BITS","text":"The amount of bits in one byte.","title":"BITS"},{"location":"reference/#colors.constants.DOUBLE_BITS","text":"The amount of bits in two bytes.","title":"DOUBLE_BITS"},{"location":"reference/#colors.constants.BLACK","text":"The black color value.","title":"BLACK"},{"location":"reference/#colors.constants.WHITE","text":"The white color value.","title":"WHITE"},{"location":"reference/#colors.constants.RED_BYTE","text":"The byte representing the red channel.","title":"RED_BYTE"},{"location":"reference/#colors.constants.GREEN_BYTE","text":"The byte representing the green channel.","title":"GREEN_BYTE"},{"location":"reference/#colors.constants.BLUE_BYTE","text":"The byte representing the blue channel.","title":"BLUE_BYTE"},{"location":"reference/#colors.typing.RGB","text":"Represents RGB color tuples.","title":"RGB"},{"location":"reference/#colors.typing.RGBA","text":"Represents RGBA color tuples.","title":"RGBA"},{"location":"reference/#colors.typing.HSV","text":"Represents HSV color tuples.","title":"HSV"},{"location":"security/","text":"Security Policy Reporting Thank you for taking the time to responsibly disclose any problems you find. Do not file public issues as they are open for everyone to see! All security vulnerabilities in colors-core should be reported by email to security@nekit.dev . Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report. You can encrypt your report using our public key: BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A . This key is also available on MIT's Key Server and reproduced below . After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours. Disclosure Policy colors-core has a 5-step disclosure process: The security report is received and is assigned a primary handler. This person will coordinate the fix and release process. The problem is confirmed and a list of all affected versions is determined. Code is audited to find any potential similar problems. Fixes are prepared for all releases which are still under maintenance. These fixes are not committed to the public repository but rather held locally pending the announcement. On the embargo date, the changes are pushed to the public repository and new builds are deployed. This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner. Security Key -----BEGIN PGP PUBLIC KEY BLOCK----- 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 1oYi7ft0FnZ67Wnk5+E+ =VRe2 -----END PGP PUBLIC KEY BLOCK----- Attribution This Security Policy is adapted from Rust's Security Policy .","title":"Security"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#reporting","text":"Thank you for taking the time to responsibly disclose any problems you find. Do not file public issues as they are open for everyone to see! All security vulnerabilities in colors-core should be reported by email to security@nekit.dev . Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report. You can encrypt your report using our public key: BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A . This key is also available on MIT's Key Server and reproduced below . After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.","title":"Reporting"},{"location":"security/#disclosure-policy","text":"colors-core has a 5-step disclosure process: The security report is received and is assigned a primary handler. This person will coordinate the fix and release process. The problem is confirmed and a list of all affected versions is determined. Code is audited to find any potential similar problems. Fixes are prepared for all releases which are still under maintenance. These fixes are not committed to the public repository but rather held locally pending the announcement. On the embargo date, the changes are pushed to the public repository and new builds are deployed. This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.","title":"Disclosure Policy"},{"location":"security/#security-key","text":"-----BEGIN PGP PUBLIC KEY BLOCK----- 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 1oYi7ft0FnZ67Wnk5+E+ =VRe2 -----END PGP PUBLIC KEY BLOCK-----","title":"Security Key"},{"location":"security/#attribution","text":"This Security Policy is adapted from Rust's Security Policy .","title":"Attribution"}]}